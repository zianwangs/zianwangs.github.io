<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12-Major Roulette</title>
    <style type="text/css">
        * {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            overflow: hidden;
        }

        .player-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .wheel-container {
            position: relative;
            width: 65vmin;
            height: 65vmin;
            margin-top: -25vh;
        }

        .wheel {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid #333;
            transform-origin: center;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            cursor: grab;
        }

        .wheel:active {
            cursor: grabbing;
        }

        .key-marker {
            position: absolute;
            transform-origin: center;
            font-size: min(4vmin, 24px);
            font-weight: normal;
            color: #333;
        }

        .pointer {
            position: absolute;
            top: 0;
            left: 50%;
            width: 0.3vmin;
            min-width: 2px;
            height: 2.5vmin;
            min-height: 5px;
            background-color: #d32f2f;
            transform: translateX(-50%);
            z-index: 3;
        }

        .center-display {
            position: absolute;
            width: 17vmin;
            height: 17vmin;
            min-width: 60px;
            min-height: 60px;
            border-radius: 50%;
            background-color: #fff;
            border: 2px solid #333;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.1s ease;
        }

        .pulsing {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(51, 51, 51, 0.3);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
                box-shadow: 0 0 10px 5px rgba(51, 51, 51, 0.2);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(51, 51, 51, 0.3);
            }
        }

        .current-key {
            font-size: min(8vmin, 48px);
            font-weight: normal;
            transition: all 0.1s ease;
        }

        .key-pulsing {
            animation: keyPulse 0.5s ease-in-out infinite;
        }

        @keyframes keyPulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: rgba(211, 47, 47, 0.7);
            pointer-events: none;
            z-index: 1;
        }

        .wheel-glow {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            top: 0;
            left: 0;
            background: transparent;
            box-shadow: 0 0 0 0 rgba(51, 51, 51, 0);
            transform-origin: center;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            z-index: 1;
        }

        .wheel-glow-active {
            animation: wheelGlow 2s ease-in-out infinite;
        }

        @keyframes wheelGlow {
            0% {
                box-shadow: 0 0 0 0 rgba(51, 51, 51, 0.2);
            }
            50% {
                box-shadow: 0 0 20px 10px rgba(51, 51, 51, 0.3);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(51, 51, 51, 0.2);
            }
        }

        .controls-wrapper {
            position: absolute;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 4;
            margin-top: 75vmin;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 2vh;
        }

        .btn {
            width: 9vmin;
            height: 9vmin;
            min-width: 40px;
            min-height: 40px;
            max-width: 60px;
            max-height: 60px;
            border-radius: 50%;
            background-color: #fff;
            border: 2px solid #333;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 2vmin;
            cursor: pointer;
            font-size: min(4vmin, 24px);
            text-align: center;
        }

        .playpause {
            width: 12vmin;
            height: 12vmin;
            min-width: 50px;
            min-height: 50px;
            max-width: 80px;
            max-height: 80px;
            font-size: min(5.5vmin, 38px);
        }

        .btn:active {
            background-color: #eee;
        }

        .progress-container {
            width: 80%;
            max-width: 500px;
            height: 1vh;
            min-height: 4px;
            background-color: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background-color: #333;
            transition: width 0.1s linear;
            position: absolute;
            top: 0;
            left: 0;
        }

        .progress-handle {
            width: 3vmin;
            height: 3vmin;
            min-width: 12px;
            min-height: 12px;
            max-width: 18px;
            max-height: 18px;
            background-color: #333;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            cursor: grab;
        }

        .progress-handle:active {
            cursor: grabbing;
        }

        .song-indicator {
            font-size: min(3vmin, 16px);
            color: #333;
            margin-bottom: 1vh;
        }

        .sharp, .flat {
            font-family: 'Times New Roman', Times, serif;
            position: relative;
        }

        .key-marker .flat {
            font-size: min(3vmin, 30px);
        }
        
        .current-key .flat, .current-key .sharp {
            font-size: min(6vmin, 48px);
        }

        .current-key .flat {
            margin-left: -1vmin;
            padding-left: -1vmin;
            font-size: min(6vmin, 30px);
        }

        #prev-song>span, #next-song>span {
            font-weight: 600;
            font-size: min(5vmin, 32px);
            margin-top: -1.1vmin;
            font-size: 1.5em;
        }

        .visualizer-container {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
        }

        .visualizer-bar {
            position: absolute;
            bottom: 0;
            width: 4px;
            background-color: rgba(211, 47, 47, 0.5);
            transform-origin: bottom center;
        }
    </style>
</head>
<body>
    <div class="player-container">
        <div class="wheel-container">
            <div class="pointer"></div>
            <div id="wheel" class="wheel"></div>
            <div id="wheel-glow" class="wheel-glow"></div>
            <div id="visualizer-container" class="visualizer-container"></div>
            <div id="center-display" class="center-display">
                <div id="current-key" class="current-key">C</div>
            </div>
        </div>
        
        <div class="controls-wrapper">
            <div class="song-indicator" id="song-indicator">Song 1 of 4</div>
            
            <div class="progress-container" id="progress-container">
                <div id="progress-bar" class="progress-bar"></div>
                <div id="progress-handle" class="progress-handle"></div>
            </div>
            
            <div class="controls">
                <div id="prev-song" class="btn"><span>←</span></div>
                <div id="playpause" class="btn playpause">▶</div>
                <div id="next-song" class="btn"><span>→</span></div>
            </div>
        </div>
    </div>

    <audio id="myaudio" loop="true" type="audio/mpeg"></audio>

    <script>
        const TONES = 12;
        const songsPerTone = {
            0: 4,  // C
            1: 3,  // C♯
            2: 2,  // D
            3: 3,  // E♭
            4: 4,  // E
            5: 2,  // F
            6: 3,  // F♯
            7: 3,  // G
            8: 5,  // A♭
            9: 3,  // A
            10: 3, // B♭
            11: 2, // B
        };
        
        const currentSongPerTone = {
            0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0
        };
        
        const keySigs = {
            0: "C",
            1: "C<span class='sharp'>♯</span>",
            2: "D",
            3: "E<span class='flat'>♭</span>",
            4: "E",
            5: "F",
            6: "F<span class='sharp'>♯</span>",
            7: "G",
            8: "A<span class='flat'>♭</span>",
            9: "A",
            10: "B<span class='flat'>♭</span>",
            11: "B",
        };
        
        let currentTone = 0; // C initially
        let currentSong = currentSongPerTone[currentTone];
        let playing = false;
        let rotation = -currentTone * 30; // Initial rotation based on C
        let startAngle = 0;
        let currentAngle = 0;
        let isDragging = false;
        let isProgressDragging = false;
        
        // Audio analysis variables
        let audioContext;
        let analyser;
        let source;
        let dataArray;
        let particles = [];
        let visualizerBars = [];
        let visualizerInitialized = false;
        
        const audio = document.getElementById("myaudio");
        const wheel = document.getElementById("wheel");
        const wheelGlow = document.getElementById("wheel-glow");
        const centerDisplay = document.getElementById("center-display");
        const currentKeyDisplay = document.getElementById("current-key");
        const playPauseBtn = document.getElementById("playpause");
        const nextSongBtn = document.getElementById("next-song");
        const prevSongBtn = document.getElementById("prev-song");
        const progressBar = document.getElementById("progress-bar");
        const progressHandle = document.getElementById("progress-handle");
        const progressContainer = document.getElementById("progress-container");
        const songIndicator = document.getElementById("song-indicator");
        const visualizerContainer = document.getElementById("visualizer-container");
        
        // Initialize audio
        audio.src = `static/audios/${currentTone}/${currentSong}.mp3`;
        updateSongIndicator();
        
        // Create key markers on the wheel
        for (let i = 0; i < TONES; i++) {
            const angle = (i * 30) * (Math.PI / 180);
            // Larger radius to place markers near the edge
            const x = 50 + Math.sin(angle) * 45;
            const y = 50 - Math.cos(angle) * 45;
            
            const marker = document.createElement("div");
            marker.className = "key-marker";
            marker.innerHTML = keySigs[i];
            marker.style.left = `${x}%`;
            marker.style.top = `${y}%`;
            marker.style.transform = `translate(-50%, -50%)`;
            
            wheel.appendChild(marker);
        }
        
        // Set initial display
        currentKeyDisplay.innerHTML = keySigs[currentTone];
        // Set initial wheel rotation to match C
        wheel.style.transform = `rotate(${rotation}deg)`;
        wheelGlow.style.transform = `rotate(${rotation}deg)`;
        
        // Initialize audio analyser
        function initAudioAnalyser() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                // Create visualizer bars
                if (!visualizerInitialized) {
                    for (let i = 0; i < 36; i++) {
                        const bar = document.createElement('div');
                        bar.className = 'visualizer-bar';
                        const angle = (i * 10) * (Math.PI / 180);
                        bar.style.left = `calc(50% + ${Math.sin(angle) * 37}%)`;
                        bar.style.height = '0px';
                        bar.style.transform = `rotate(${i * 10}deg)`;
                        visualizerContainer.appendChild(bar);
                        visualizerBars.push(bar);
                    }
                    visualizerInitialized = true;
                }
                
                // Start animation
                animateAudio();
            }
        }
        
        // Create particle effect
        function createParticle(intensity) {
            const rect = centerDisplay.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 35 + 10; // Distance from center
            
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = `${centerX + Math.cos(angle) * distance}px`;
            particle.style.top = `${centerY + Math.sin(angle) * distance}px`;
            
            // Make particle size based on intensity
            const size = Math.max(3, intensity / 25);
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            
            // Randomize color based on key
            const hue = (currentTone * 30) % 360;
            particle.style.backgroundColor = `hsla(${hue}, 80%, 60%, 0.7)`;
            
            document.body.appendChild(particle);
            
            // Add to particles array for cleanup
            particles.push({
                element: particle,
                life: 60, // frames to live
                angle: angle,
                distance: distance,
                speed: Math.random() * 2 + 1,
                x: centerX + Math.cos(angle) * distance,
                y: centerY + Math.sin(angle) * distance
            });
        }
        
        // Animate particles
        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.life--;
                
                // Move particle outward
                particle.distance += particle.speed;
                particle.x = centerDisplay.getBoundingClientRect().left + centerDisplay.getBoundingClientRect().width / 2 + Math.cos(particle.angle) * particle.distance;
                particle.y = centerDisplay.getBoundingClientRect().top + centerDisplay.getBoundingClientRect().height / 2 + Math.sin(particle.angle) * particle.distance;
                
                particle.element.style.left = `${particle.x}px`;
                particle.element.style.top = `${particle.y}px`;
                
                // Fade out
                particle.element.style.opacity = particle.life / 60;
                
                // Remove dead particles
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(index, 1);
                }
            });
        }
        
        // Animate audio visualizer
        function animateAudio() {
            if (!playing) {
                requestAnimationFrame(animateAudio);
                return;
            }
            
            analyser.getByteFrequencyData(dataArray);
            
            // Calculate average amplitude for center display pulsing
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const avg = sum / dataArray.length;
            
            // Use average to scale center display
            const scale = 1 + (avg / 255) * 0.2; // Scale between 1 and 1.2
            centerDisplay.style.transform = `translate(-50%, -50%) scale(${scale})`;
            
            // Create particles based on bass frequencies
            const bassPower = (dataArray[1] + dataArray[2] + dataArray[3]) / 3;
            if (bassPower > 200 && Math.random() > 0.7) {
                createParticle(bassPower);
            }
            
            // Update visualizer bars
            for (let i = 0; i < visualizerBars.length; i++) {
                const dataIndex = Math.floor(i * dataArray.length / visualizerBars.length);
                const barHeight = (dataArray[dataIndex] / 255) * 50;
                visualizerBars[i].style.height = `${barHeight}%`;
            }
            
            // Update existing particles
            updateParticles();
            
            requestAnimationFrame(animateAudio);
        }
        
        // Audio play/pause function
        function togglePlayPause() {
            if (playing) {
                audio.pause();
                playPauseBtn.innerHTML = "▶";
                centerDisplay.classList.remove('pulsing');
                currentKeyDisplay.classList.remove('key-pulsing');
                wheelGlow.classList.remove('wheel-glow-active');
            } else {
                // Start audio context if needed (for browser autoplay policy)
                if (audioContext === undefined) {
                    initAudioAnalyser();
                } else if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                let playPromise = audio.play();
                playPromise.catch(() => {});
                playPauseBtn.innerHTML = "❚❚";
                centerDisplay.classList.add('pulsing');
                currentKeyDisplay.classList.add('key-pulsing');
                wheelGlow.classList.add('wheel-glow-active');
            }
            playing = !playing;
            changeIndent();
        }
        
        // Switch audio function with improved rotation logic
        function switchAudio(toneDelta, songDelta) {
            if (toneDelta !== 0) {
                // Calculate new tone
                let newTone = (currentTone + toneDelta + TONES) % TONES;
                
                // Calculate the shortest path to rotate
                let rotationDelta = ((newTone - currentTone + TONES) % TONES);
                if (rotationDelta > TONES / 2) {
                    rotationDelta = rotationDelta - TONES;
                }
                
                // Update rotation and tone
                rotation -= rotationDelta * 30;
                currentTone = newTone;
                
                wheel.style.transform = `rotate(${rotation}deg)`;
                wheelGlow.style.transform = `rotate(${rotation}deg)`;
            }
            
            currentSong = (currentSongPerTone[currentTone] + songDelta + songsPerTone[currentTone]) % songsPerTone[currentTone];
            currentSongPerTone[currentTone] = currentSong;
            updateSongIndicator();
            
            currentKeyDisplay.innerHTML = keySigs[currentTone];
            audio.src = `static/audios/${currentTone}/${currentSong}.mp3`;
            
            if (playing) {
                // Update audio source if already playing
                if (source && audioContext) {
                    source.disconnect();
                    source = audioContext.createMediaElementSource(audio);
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                }
                
                let playPromise = audio.play();
                playPromise.catch(() => {});
            }
            changeIndent();
        }
        
        function updateSongIndicator() {
            songIndicator.textContent = `Song ${currentSong + 1} of ${songsPerTone[currentTone]}`;
        }
        
        // Event listeners
        playPauseBtn.addEventListener("click", togglePlayPause);
        nextSongBtn.addEventListener("click", () => switchAudio(0, 1));
        prevSongBtn.addEventListener("click", () => switchAudio(0, -1));
        
        // Wheel rotation events
        wheel.addEventListener("mousedown", startDrag);
        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", endDrag);
        
        // Touch events
        wheel.addEventListener("touchstart", handleTouchStart);
        document.addEventListener("touchmove", handleTouchMove);
        document.addEventListener("touchend", handleTouchEnd);
        
        function startDrag(e) {
            isDragging = true;
            const rect = wheel.getBoundingClientRect();
            const wheelCenterX = rect.left + rect.width / 2;
            const wheelCenterY = rect.top + rect.height / 2;
            startAngle = Math.atan2(e.clientY - wheelCenterY, e.clientX - wheelCenterX) * 180 / Math.PI;
            e.preventDefault();
        }
        
        function drag(e) {
            if (!isDragging) return;
            
            const rect = wheel.getBoundingClientRect();
            const wheelCenterX = rect.left + rect.width / 2;
            const wheelCenterY = rect.top + rect.height / 2;
            
            const angle = Math.atan2(e.clientY - wheelCenterY, e.clientX - wheelCenterX) * 180 / Math.PI;
            const deltaAngle = angle - startAngle;
            
            wheel.style.transform = `rotate(${rotation + deltaAngle}deg)`;
            wheelGlow.style.transform = `rotate(${rotation + deltaAngle}deg)`;
            
            // Calculate the current tone based on wheel position
            // Get the actual rotation amount (considering our starting rotation)
            const totalRotation = (rotation + deltaAngle) % 360;
            // Convert to tone index (normalized to positive values)
            const calculatedTone = Math.round(-totalRotation / 30) % TONES;
            const normalizedTone = (calculatedTone + TONES) % TONES;
            
            if (normalizedTone !== currentTone) {
                // Update tone without a big wheel movement
                currentTone = normalizedTone;
                currentSong = currentSongPerTone[currentTone];
                currentKeyDisplay.innerHTML = keySigs[currentTone];
                audio.src = `static/audios/${currentTone}/${currentSong}.mp3`;
                updateSongIndicator();
                
                if (playing) {
                    // Update audio source if already playing
                    if (source && audioContext) {
                        source.disconnect();
                        source = audioContext.createMediaElementSource(audio);
                        source.connect(analyser);
                        analyser.connect(audioContext.destination);
                    }
                    
                    let playPromise = audio.play();
                    playPromise.catch(() => {});
                }
            }
        }
        
        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            
            const rect = wheel.getBoundingClientRect();
            const wheelCenterX = rect.left + rect.width / 2;
            const wheelCenterY = rect.top + rect.height / 2;
            
            // Calculate final angle
            const finalAngle = Math.atan2(e.clientY - wheelCenterY, e.clientX - wheelCenterX) * 180 / Math.PI;
            const totalDeltaAngle = finalAngle - startAngle;
            
            // Update rotation to the final position
            rotation = rotation + totalDeltaAngle;
            
            // Snap to the nearest key
            const snapAngle = Math.round(rotation / 30) * 30;
            rotation = snapAngle;
            
            wheel.style.transform = `rotate(${rotation}deg)`;
            wheelGlow.style.transform = `rotate(${rotation}deg)`;
            
            // Make sure the tone is correct
            const snapTone = Math.round(-rotation / 30) % TONES;
            currentTone = (snapTone + TONES) % TONES;
            currentKeyDisplay.innerHTML = keySigs[currentTone];
            changeIndent();
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent("mousedown", {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            startDrag(mouseEvent);
        }
        
        function handleTouchMove(e) {
            if (!isDragging) return;
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent("mousemove", {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            drag(mouseEvent);
        }
        
        function handleTouchEnd(e) {
            const touch = e.changedTouches[0];
            const mouseEvent = new MouseEvent("mouseup", {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            endDrag(mouseEvent);
        }
        
        // Keyboard controls
        document.addEventListener("keyup", function(e) {
            if (e.key === "Enter" || e.key === " ") {
                togglePlayPause();
            } else if (e.key === "ArrowUp" || e.key === "w") {
                switchAudio(0, -1);
            } else if (e.key === "ArrowDown" || e.key === "s") {
                switchAudio(0, 1);
            } else if (e.key === "ArrowRight" || e.key === "d") {
                switchAudio(1, 0);
            } else if (e.key === "ArrowLeft" || e.key === "a") {
                switchAudio(-1, 0);
            }
        });
        
        // Update progress bar
        audio.addEventListener("timeupdate", function() {
            if (!isProgressDragging) {
                const percent = (audio.currentTime / audio.duration) * 100;
                updateProgressBar(percent);
            }
        });
        
        // Draggable progress bar functions
        function updateProgressBar(percent) {
            if (isNaN(percent)) percent = 0;
            percent = Math.min(100, Math.max(0, percent));
            progressBar.style.width = `${percent}%`;
            progressHandle.style.left = `${percent}%`;
        }
        
        function seekAudio(percent) {
            if (audio.duration) {
                audio.currentTime = (percent / 100) * audio.duration;
            }
        }
        
        // Progress bar click event
        progressContainer.addEventListener("click", function(e) {
            if (isProgressDragging) return;
            
            const rect = progressContainer.getBoundingClientRect();
            const percent = ((e.clientX - rect.left) / rect.width) * 100;
            updateProgressBar(percent);
            seekAudio(percent);
        });
        
        // Progress handle drag events
        progressHandle.addEventListener("mousedown", startProgressDrag);
        document.addEventListener("mousemove", dragProgress);
        document.addEventListener("mouseup", endProgressDrag);
        
        // Progress handle touch events
        progressHandle.addEventListener("touchstart", handleProgressTouchStart);
        document.addEventListener("touchmove", handleProgressTouchMove);
        document.addEventListener("touchend", handleProgressTouchEnd);
        
        function startProgressDrag(e) {
            isProgressDragging = true;
            e.stopPropagation();
            e.preventDefault();
        }
        
        function dragProgress(e) {
            if (!isProgressDragging) return;
            
            const rect = progressContainer.getBoundingClientRect();
            let percent = ((e.clientX - rect.left) / rect.width) * 100;
            percent = Math.min(100, Math.max(0, percent));
            
            updateProgressBar(percent);
        }
        
        function endProgressDrag(e) {
            if (!isProgressDragging) return;
            
            const rect = progressContainer.getBoundingClientRect();
            let percent = ((e.clientX - rect.left) / rect.width) * 100;
            percent = Math.min(100, Math.max(0, percent));
            
            updateProgressBar(percent);
            seekAudio(percent);
            
            isProgressDragging = false;
        }
        
        function handleProgressTouchStart(e) {
            const touch = e.touches[0];
            isProgressDragging = true;
            e.stopPropagation();
            e.preventDefault();
        }
        
        function handleProgressTouchMove(e) {
            if (!isProgressDragging) return;
            
            const touch = e.touches[0];
            const rect = progressContainer.getBoundingClientRect();
            let percent = ((touch.clientX - rect.left) / rect.width) * 100;
            percent = Math.min(100, Math.max(0, percent));
            
            updateProgressBar(percent);
            e.preventDefault();
        }
        
        function handleProgressTouchEnd(e) {
            if (!isProgressDragging) return;
            
            const touch = e.changedTouches[0];
            const rect = progressContainer.getBoundingClientRect();
            let percent = ((touch.clientX - rect.left) / rect.width) * 100;
            percent = Math.min(100, Math.max(0, percent));
            
            updateProgressBar(percent);
            seekAudio(percent);
            
            isProgressDragging = false;
        }
        
        function changeIndent() {
            if (playPauseBtn.innerHTML == "▶") {
                playPauseBtn.style.textIndent = "1vmin";
            } else {
                playPauseBtn.style.textIndent = "0.1vmin";
            }
        
            span = currentKeyDisplay.querySelector('span');
            if (span && span.innerHTML == "♭") {
                currentKeyDisplay.style.marginLeft = "1.3vmin";
            } else {
                currentKeyDisplay.style.marginLeft = "0";
            }
        }
        
        // Initialize the pulsing effect and clean up abandoned particles
        function cleanupParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].element.remove();
            }
            particles = [];
        }
        
        // Handle window resize to adjust particle positioning
        window.addEventListener('resize', function() {
            if (visualizerInitialized) {
                cleanupParticles();
            }
        });
        
        // Cleanup when switching audio
        audio.addEventListener('ended', function() {
            if (playing) {
                switchAudio(0, 1); // Auto-advance to next song
            }
        });
        
        // Handle visibility changes to pause/resume animations
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && playing) {
                // Pause animations when tab is not visible
                cleanupParticles();
            }
        });
        
        changeIndent();
    </script>
</body>
</html>